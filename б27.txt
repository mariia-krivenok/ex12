import sqlite3
import tkinter as tk
from tkinter import messagebox


# Создание базы данных и подключение
conn = sqlite3.connect('phone_station.db')
cursor = conn.cursor()

# Создание таблиц (если они не существуют)
cursor.execute('''
CREATE TABLE IF NOT EXISTS Tariffs (
    tariff_id INTEGER PRIMARY KEY AUTOINCREMENT,
    min_distance INTEGER,
    max_distance INTEGER,
    price_per_minute REAL
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS Cities (
    city_id INTEGER PRIMARY KEY AUTOINCREMENT,
    city_name TEXT NOT NULL,
    distance INTEGER NOT NULL,
    tariff_id INTEGER NOT NULL,
    FOREIGN KEY (tariff_id) REFERENCES Tariffs(tariff_id)
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS Calls (
    call_id INTEGER PRIMARY KEY AUTOINCREMENT,
    city_id INTEGER NOT NULL,
    start_time TEXT NOT NULL,
    duration INTEGER NOT NULL,
    FOREIGN KEY (city_id) REFERENCES Cities(city_id)
)
''')

conn.commit()

# Функции для добавления данных

# Добавление тарифа
def add_tariff():
    def save_tariff():
        try:
            min_distance = int(min_distance_entry.get())
            max_distance = int(max_distance_entry.get())
            price_per_minute = float(price_per_minute_entry.get())

            cursor.execute(
                "INSERT INTO Tariffs (min_distance, max_distance, price_per_minute) VALUES (?, ?, ?)",
                (min_distance, max_distance, price_per_minute)
            )
            conn.commit()
            messagebox.showinfo("Успех", "Тариф успешно добавлен!")
            add_tariff_window.destroy()
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные данные!")

    add_tariff_window = tk.Toplevel(root)
    add_tariff_window.title("Добавить тариф")

    tk.Label(add_tariff_window, text="Минимальное расстояние (км):").pack(pady=5)
    min_distance_entry = tk.Entry(add_tariff_window)
    min_distance_entry.pack(pady=5)

    tk.Label(add_tariff_window, text="Максимальное расстояние (км):").pack(pady=5)
    max_distance_entry = tk.Entry(add_tariff_window)
    max_distance_entry.pack(pady=5)

    tk.Label(add_tariff_window, text="Цена за минуту (руб.):").pack(pady=5)
    price_per_minute_entry = tk.Entry(add_tariff_window)
    price_per_minute_entry.pack(pady=5)

    tk.Button(add_tariff_window, text="Сохранить", command=save_tariff).pack(pady=10)


# Добавление города
def add_city():
    def save_city():
        try:
            city_name = city_name_entry.get()
            distance = int(distance_entry.get())
            tariff_id = int(tariff_id_entry.get())

            # Проверяем, существует ли указанный тариф
            cursor.execute("SELECT tariff_id FROM Tariffs WHERE tariff_id = ?", (tariff_id,))
            if cursor.fetchone() is None:
                messagebox.showerror("Ошибка", "Указанный тариф не существует!")
                return

            cursor.execute(
                "INSERT INTO Cities (city_name, distance, tariff_id) VALUES (?, ?, ?)",
                (city_name, distance, tariff_id)
            )
            conn.commit()
            messagebox.showinfo("Успех", "Город успешно добавлен!")
            add_city_window.destroy()
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные данные!")

    add_city_window = tk.Toplevel(root)
    add_city_window.title("Добавить город")

    tk.Label(add_city_window, text="Название города:").pack(pady=5)
    city_name_entry = tk.Entry(add_city_window)
    city_name_entry.pack(pady=5)

    tk.Label(add_city_window, text="Расстояние (км):").pack(pady=5)
    distance_entry = tk.Entry(add_city_window)
    distance_entry.pack(pady=5)

    tk.Label(add_city_window, text="ID тарифа:").pack(pady=5)
    tariff_id_entry = tk.Entry(add_city_window)
    tariff_id_entry.pack(pady=5)

    tk.Button(add_city_window, text="Сохранить", command=save_city).pack(pady=10)


# Добавление звонка
def add_call():
    def save_call():
        try:
            city_id = int(city_id_entry.get())
            start_time = start_time_entry.get()
            duration = int(duration_entry.get())

            # Проверяем, существует ли указанный город
            cursor.execute("SELECT city_id FROM Cities WHERE city_id = ?", (city_id,))
            if cursor.fetchone() is None:
                messagebox.showerror("Ошибка", "Указанный город не существует!")
                return

            cursor.execute(
                "INSERT INTO Calls (city_id, start_time, duration) VALUES (?, ?, ?)",
                (city_id, start_time, duration)
            )
            conn.commit()
            messagebox.showinfo("Успех", "Звонок успешно добавлен!")
            add_call_window.destroy()
        except ValueError:
            messagebox.showerror("Ошибка", "Пожалуйста, введите корректные данные!")

    add_call_window = tk.Toplevel(root)
    add_call_window.title("Добавить звонок")

    tk.Label(add_call_window, text="ID города:").pack(pady=5)
    city_id_entry = tk.Entry(add_call_window)
    city_id_entry.pack(pady=5)

    tk.Label(add_call_window, text="Время начала (HH:MM):").pack(pady=5)
    start_time_entry = tk.Entry(add_call_window)
    start_time_entry.pack(pady=5)

    tk.Label(add_call_window, text="Длительность (мин.):").pack(pady=5)
    duration_entry = tk.Entry(add_call_window)
    duration_entry.pack(pady=5)

    tk.Button(add_call_window, text="Сохранить", command=save_call).pack(pady=10)


# Функции для вывода данных

# Сортировка разговоров
def show_sorted_calls():
    cursor.execute('''
    SELECT Calls.start_time, Calls.duration, Cities.city_name
    FROM Calls
    JOIN Cities ON Calls.city_id = Cities.city_id
    ORDER BY Calls.start_time
    ''')
    calls = cursor.fetchall()

    output_text.delete(1.0, tk.END)
    output_text.insert(tk.END, "Список разговоров (по времени начала):\n")
    for call in calls:
        output_text.insert(tk.END, f"Город: {call[2]}, Начало: {call[0]}, Длительность: {call[1]} мин.\n")


# Доля стоимости разговоров по городам
def show_city_share():
    cursor.execute('''
    SELECT Cities.city_name, SUM(Calls.duration * Tariffs.price_per_minute) AS total_cost
    FROM Calls
    JOIN Cities ON Calls.city_id = Cities.city_id
    JOIN Tariffs ON Cities.tariff_id = Tariffs.tariff_id
    GROUP BY Cities.city_name
    ''')
    costs = cursor.fetchall()

    cursor.execute('''
    SELECT SUM(Calls.duration * Tariffs.price_per_minute) FROM Calls
    JOIN Cities ON Calls.city_id = Cities.city_id
    JOIN Tariffs ON Cities.tariff_id = Tariffs.tariff_id
    ''')
    total_cost = cursor.fetchone()[0] or 0

    output_text.delete(1.0, tk.END)
    if total_cost == 0:
        output_text.insert(tk.END, "Данные отсутствуют для расчета доли стоимости.\n")
        return

    output_text.insert(tk.END, "Доля стоимости разговоров по городам:\n")
    for city_name, city_cost in costs:
        share = (city_cost / total_cost) * 100
        output_text.insert(tk.END, f"Город: {city_name}, Суммарная стоимость: {city_cost:.2f} руб., Доля: {share:.2f}%\n")


# Главный интерфейс
root = tk.Tk()
root.title("Междугородняя телефонная станция")

# Кнопки для добавления данных
tk.Button(root, text="Добавить тариф", command=add_tariff).pack(pady=5)
tk.Button(root, text="Добавить город", command=add_city).pack(pady=5)
tk.Button(root, text="Добавить звонок", command=add_call).pack(pady=5)

# Кнопки для вывода данных
tk.Button(root, text="Показать список разговоров", command=show_sorted_calls).pack(pady=5)
tk.Button(root, text="Показать долю стоимости", command=show_city_share).pack(pady=5)

# Поле для вывода результатов
output_text = tk.Text(root, width=70, height=20)
output_text.pack(padx=10, pady=10)

# Запуск приложения
root.mainloop()

# Закрытие базы данных
conn.close()
